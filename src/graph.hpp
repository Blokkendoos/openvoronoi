/*  
 *  Copyright 2010-2011 Anders Wallin (anders.e.e.wallin "at" gmail.com)
 *  
 *  This file is part of OpenVoronoi.
 *
 *  OpenCAMlib is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  OpenCAMlib is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with OpenCAMlib.  If not, see <http://www.gnu.org/licenses/>.
*/

#ifndef VODI_G_HPP
#define VODI_G_HPP

#include <vector>

#include <boost/graph/adjacency_list.hpp>

#include "common/point.hpp"
#include "common/halfedgediagram.hpp"
#include "vertex.hpp"
#include "site.hpp"
#include "edge.hpp"

// this file contains typedefs used by voronoidiagram.h
namespace ovd {

// notes from the Okabe-Boots-Sugihara book, page 171->:
/* 
 * Distance-function.
 * R1 - region of endpoint pi1
 * R2 - region of endpoint pi2
 * R3 - region of line-segment Li
 *               dist(p,pi1) if  p in R1
 * dist(p,Li) =  dist(p,pi2) if  p in R2
 *               dist(p,Li)  if p in R3
 * 
 * dist(p,Li) = distance from p to L, along perpendicular line to L
 * 
 * = norm(  (x-xi1)   -  dotprod( (x-xi1), (xi2-xi1) ) / ( norm_sq(xi2-xi1) ) * (xi2,xi1) )
 * 
 * 
 * 
 * Vertex - LineSegment
 * Bisectors:
 *  B1: point-point: line
 *  B2: point-line: parabola
 *  B3: line-line: line
 * 
 *  Voronoi Edges:
 *  E1: point pi - point pj. straight line bisecting pi-pj
 *  E2: edge generated by line-segment L's endpoint pi. perpendicular to L, passing through pi
 *  E3: point pi - segment Lj. dist(E3, p) == dist(E3,Lj). Parabolic arc
 *  E4: line Li - Line Lj. straight line bisector
 *  (G): generator segment edge
 * 
 *  Voronoi vertices (see p177 of Okabe book):
 *  V1: generators(pi, pj, pk). edges(E1, E1, E1)
 *     - compute using detH. This is also the circumcenter of the pi,pj,pk triangle
 *  V2: generators(pi, Lj, pj1) point, segment, segment's endpoint. edges(E1, E2, E3)   E1 and E3 are tangent at V2
 *     - ? compute by mirroring pi in the separator and use detH
 *  V3: generators(Li, pj, pk) edges(E1, E3, E3)   E3-edges have common directrix(Li)
 *  V4: generators(Li, Lj, pi1)  edges(E2, E3, E4)  E3-E4 tangent at V4
 *  V5: generators(pi, Lj, Lk) edges (E3, E3, E4)
 *  V6: generators(Li, Lj, Lk) edges(E4, E4, E4)
 *    - this is the incenter of a incircle inscribed by triangle Li,Lj,Lk (or sometiems excenter of excircle if V6 outside triangle?)
 *    - The Cartesian coordinates of the incenter are a weighted average of the coordinates of the three vertices using the side 
 *       lengths of the triangle as weights. (The weights are positive so the incenter lies inside the triangle as stated above.) 
 *      If the three vertices are located at (xa,ya), (xb,yb), and (xc,yc), and the sides opposite these vertices have corresponding 
 *      lengths a, b, and c, then the incenter is at   
 *      (a x_a + b x_b + c x_c)/ (a+b+c) 
 * 
 * bisector formulas
 * x = x1 - x2 - x3*t +/- x4 * sqrt( square(x5+x6*t) - square(x7+x8*t) )
 * (same formula for y-coordinate)
 * line (line/line)
 * parabola (circle/line)
 * hyperbola (circle/circle)
 * ellipse (circle/circle)
 * 
 * line: a1*x + b1*y + c + k*t = 0  (t is amount of offset) k=+1 offset left of line, k=-1 right of line
 * with a*a + b*b = 1
 * 
 * circle: square(x-xc) + square(y-yc) = square(r+k*t)  k=+1 for enlarging circle, k=-1 shrinking
 */
 

// use traits-class here so that EdgePros can store data of type HEEdge
// typedef of the VD-graph follows below. 

// vecS is slightly faster than listS
// vecS   5.72us * n log(n)
// listS  6.18 * n log(n)
#define OUT_EDGE_CONTAINER boost::listS 

// note: cannot use vecS since remove_vertex invalidates iterators/edge_descriptors (?)
#define VERTEX_CONTAINER boost::listS
#define EDGE_LIST_CONTAINER boost::listS

// type of edge-descriptors in the graph
typedef boost::adjacency_list_traits<OUT_EDGE_CONTAINER, 
                                     VERTEX_CONTAINER, 
                                     boost::bidirectionalS, 
                                     EDGE_LIST_CONTAINER >::edge_descriptor HEEdge;
// type of face-descriptors in the graph
typedef unsigned int HEFace;    

/// Status of faces in the voronoi diagram
/// INCIDENT faces contain one or more IN-vertex
/// NONINCIDENT faces contain only OUT-vertices
enum VoronoiFaceStatus {INCIDENT, NONINCIDENT};

/// properties of a face in the voronoi diagram
/// each face stores one edge on the boundary of the face
struct FaceProps {
    FaceProps() {
        site = 0;
    }
    virtual ~FaceProps() {
        //if (site)
        //    delete site;
    }
    /// create face with given edge, generator, and type
    FaceProps( HEEdge e , Site* s, VoronoiFaceStatus st) : edge(e), site(s), status(st) {}
    /// operator for sorting faces
    bool operator<(const FaceProps& f) const {return (this->idx<f.idx);}
    /// face index
    HEFace idx;
    /// one edge that bounds this face
    HEEdge edge;
    /// the site/generator for this face (either PointSite, LineSite, or ArcSite)
    Site* site;
    /// face status (either incident or nonincident)
    VoronoiFaceStatus status;
};

// the type of graph with which we construct the voronoi-diagram
typedef hedi::HEDIGraph< OUT_EDGE_CONTAINER,     // out-edges stored in a std::list
                       VERTEX_CONTAINER,         // vertex set stored here
                       boost::bidirectionalS,    // bidirectional graph.
                       VoronoiVertex,            // vertex properties
                       EdgeProps,                // edge properties
                       FaceProps,                // face properties
                       boost::no_property,       // graph properties
                       EDGE_LIST_CONTAINER       // edge storage
                       > HEGraph;
// NOTE: if these listS etc. arguments ever change, they must also be updated
// above where we do: adjacency_list_traits

typedef boost::graph_traits< HEGraph::BGLGraph >::vertex_descriptor  HEVertex;
typedef boost::graph_traits< HEGraph::BGLGraph >::vertex_iterator    HEVertexItr;
typedef boost::graph_traits< HEGraph::BGLGraph >::edge_iterator      HEEdgeItr;
typedef boost::graph_traits< HEGraph::BGLGraph >::out_edge_iterator  HEOutEdgeItr;
typedef boost::graph_traits< HEGraph::BGLGraph >::adjacency_iterator HEAdjacencyItr;
typedef boost::graph_traits< HEGraph::BGLGraph >::vertices_size_type HEVertexSize;

// these containers are used, for simplicity, instead of iterators (like in BGL) when accessing
// adjacent vertices, edges, faces.
// FIXME: it may be faster to rewrite the code so it uses iterators, as does the BGL.
typedef std::vector<HEVertex> VertexVector;
typedef std::vector<HEFace>   FaceVector;
typedef std::vector<HEEdge>   EdgeVector;  

} // end namespace
#endif


